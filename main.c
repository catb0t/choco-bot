#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    shootSensor,    sensorLineFollower)
#pragma config(Sensor, in2,    shootSensor2,   sensorLineFollower)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           Lshoot,        tmotorVex393TurboSpeed_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           Rfront,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           Rback,         tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           Lfront,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,            ,             tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           Loader,        tmotorNone, openLoop)
#pragma config(Motor,  port7,           Feeder,        tmotorServoStandard, openLoop)
#pragma config(Motor,  port8,           Lback,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           Servo,         tmotorNone, openLoop)
#pragma config(Motor,  port10,          Rshoot,        tmotorVex393TurboSpeed_HBridge, openLoop, reversed, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

task Shoot();
void ClearDisplay();
void PowerShooters(tMotor theMotor);
void retractServo(bool wait);
void pushServo(bool wait);

int minP = 105;
int maxP = 120;
int pTargetRPM = 195;




int adjustP = 0;
void DisplayLine(int line, string str);

void displayOnLCD()
{
	string str = "";

	ClearDisplay();
	sprintf(str, "D:%03dL:%03d",motor[Lshoot], motor[Rshoot]);
	DisplayLine(0,str);
	sprintf(str, "Volt:%1.3f %1.3f",(float)nAvgBatteryLevel/1000.0,(float)nImmediateBatteryLevel/1000);
	DisplayLine(1,str);

}



//battery display function

task display()
{
	while(true)
	{
		displayOnLCD();
		wait1Msec(500);
	}
}








/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void displayBattery()
{
	if(vexRT[Btn7R] == 1)
	{
		writeDebugStream("%04d,  ",nImmediateBatteryLevel);
	}
}

bool auton = false;

bool Shooting = false;

void shootBall() {
	Shooting = true;

	motor[Servo] = 0;

	wait1Msec(350);

	motor[Lshoot] = 127;
	motor[Rshoot] = 127;

	motor[Servo] = -127;
	wait1Msec(350);

	Shooting = false;
}

void manualShoot() {
	Shooting = true;
	PowerShooters(Lshoot);
	PowerShooters(Rshoot);
	Shooting = false;
}




void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;
	bLCDBacklight = true;
	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}







/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////
bool AutoMode = false;

task autonomous()
{
	startTask (display);
//	minP = 114;
//	maxP = 124;

//	minP = 112; third attempt
//	maxP = 118;

		minP = 114;
		maxP = 116;

	//pTargetRPM = 190;
		pTargetRPM = 190;
	int measuredRPM = 0;
	AutoMode = true;
	startTask(Shoot);

	while (true) {

		measuredRPM = (int)abs(getMotorVelocity(Rshoot));

		PowerShooters(Rshoot);
		PowerShooters(Lshoot);

		if ((SensorValue(shootSensor)) < 2500
		&& !Shooting
		&& measuredRPM > 197
		&& measuredRPM < 213
		|| SensorValue(shootSensor2) < 2500
		&& !Shooting
		&& measuredRPM > 197
		&& measuredRPM < 213 )

		{
			shootBall();
		}


		wait10Msec(1); //fixes some lag issues
	}

}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	AutoMode = false;
	startTask(Shoot);
	while(true) {
		motor[Lfront]  = vexRT[Ch3] / 2;
		motor[Lback] = vexRT[Ch3] / 2;			// Left Joystick Y value
		motor[Rfront] = vexRT[Ch2] / 2;
		motor[Rback] = vexRT[Ch2] / 2;		// Right Joystick Y value
		wait1Msec(10);


		displayLCDCenteredString(0, "Sensor Value:");
		displayLCDPos(1,6);
		displayNextLCDNumber(SensorValue(shootSensor));


	}
}



void retractServo(bool wait)
{
	motor[Servo] = -175;
	if (wait) {
		wait1Msec(350);
	}
}

void pushServo(bool wait)
{
	motor[Servo] = 175;
	if (wait) {
		wait1Msec(350);
	}
}

void DisplayRPM()
{
	while(true)
	{
		displayOnLCD();
		wait1Msec(500);
	}
}

void ClearDisplay()
{
	clearLCDLine(0);
	clearLCDLine(1);
}

void DisplayLine(int line, string str)
{
	displayLCDString(line, 0, "");
	displayNextLCDString(str);
}

void PowerShooters(tMotor theMotor) {
	int power = (int)abs(motor[theMotor]);
	int adjustment = 1;
	writeDebugStream("%03d,  ",pTargetRPM);

	int measuredRPM = 0;
	if (theMotor == Rshoot) {
		measuredRPM = (int)abs(getMotorVelocity(Rshoot));
		writeDebugStream("RShot,  ");
	}
	else {
		measuredRPM = (int)abs(getMotorVelocity(Lshoot));
		writeDebugStream("LShot,  ");
	}
	writeDebugStream("%03d, %03d, ",measuredRPM, power);


	if (pTargetRPM > measuredRPM)
		power += adjustment;
	if (pTargetRPM < measuredRPM)
		power -= adjustment;
	if(pTargetRPM == measuredRPM)
		power = power;

	writeDebugStream("%03d, ",power);

	if (power<minP)
		power = maxP;
	if (power>maxP)
		power = minP;

	writeDebugStreamLine("%03d, ",power);

	motor[theMotor] = power;

	wait1Msec(10);
}

task Shoot() {

	displayNextLCDNumber(nImmediateBatteryLevel, 1);

	motor[Servo] = -100;
	unsigned long myTime = nPgmTime;

	bool Shooting = false;
	while(true)
	{
		if ((unsigned long) (myTime + 250) > nPgmTime) {
			myTime = nPgmTime;
			if (vexRT[Btn7U]==1 ) //if the Button (7U) is pressed...
			{
				pTargetRPM++;
				minP++;
				maxP++;
			}
			if (vexRT[Btn7D]==1 ) //if the Button (7D) is pressed...
			{
				minP--;
				maxP--;
				pTargetRPM--;
			}
		}

		if (vexRT[Btn7L]==1 )
		{
			pTargetRPM = 195;
			adjustP = 0;
		}


		//Loader
			if (vexRT[Btn5D]==1 ) //if the Button (5D) is pressed...
			{
				motor[Loader] = 100;
			}
			else { //Load a ball. If not, stop the loader.
				motor[Loader] = 0;
			}


			//Servo Shoot
			if (vexRT[Btn6D]==1)
			{
				minP = 108;
				maxP = 109;
				pTargetRPM = 195;
				manualShoot();
			}
			else
			{
				motor[Rshoot] = 0;
				motor[Lshoot] = 0;
			}

			if (vexRT[Btn8R]==1)
			{
				minP = 95;
				maxP = 100;
				pTargetRPM = 195;
				manualShoot();
			}
			else
			{
				motor[Rshoot] = 0;
				motor[Lshoot] = 0;
			}

			if (vexRT[Btn6U]==1)
			{
				pushServo(false);
			}
			else
			{
				retractServo(false);
			}


			//Feeder wheels suck in the balls when the button 8D is pressed.
			if (vexRT[Btn5U]) {
				motor[Feeder] = 100;
			}
			else {
				motor[Feeder] = 0;
			}
		}
		displayBattery();


		wait1Msec(10); // allow CPU to run other tasks

	}
